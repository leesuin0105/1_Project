# -*- coding: utf-8 -*-
"""수묵화_코드

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dNz2BLxOFahl-uDN233k3FnaRBBOw0Oh

https://github.com/ShivamShrirao/diffusers/tree/main/examples/dreambooth
"""

#@markdown Check type of GPU and VRAM available.
!nvidia-smi --query-gpu=name,memory.total,memory.free --format=csv,noheader



import requests

# 파일 다운로드 함수
def download_file(url, target_path):
    response = requests.get(url)
    with open(target_path, 'wb') as f:
        f.write(response.content)
    print(f"파일 다운로드 완료: {target_path}")

# 예시: train_dreambooth.py 다운로드
train_dreambooth_url = "https://github.com/ShivamShrirao/diffusers/raw/main/examples/dreambooth/train_dreambooth.py"
download_file(train_dreambooth_url, "train_dreambooth.py")

# 예시: convert_diffusers_to_original_stable_diffusion.py 다운로드
convert_script_url = "https://github.com/ShivamShrirao/diffusers/raw/main/scripts/convert_diffusers_to_original_stable_diffusion.py"
download_file(convert_script_url, "convert_diffusers_to_original_stable_diffusion.py")

import os

# Hugging Face Hub 토큰 저장 경로
huggingface_token_path = os.path.join(os.path.expanduser("~"), ".huggingface", "token")

# Hugging Face Hub 토큰 저장
HUGGINGFACE_TOKEN = "여기에 토큰 입력"
with open(huggingface_token_path, "w") as token_file:
    token_file.write(HUGGINGFACE_TOKEN)

print("Hugging Face Hub 토큰 저장 완료.")

"""## Settings and run"""

import os

#@markdown If model weights should be saved directly in google drive (takes around 4-5 GB).
save_to_gdrive = True #@param {type:"boolean"}


#@markdown Name/Path of the initial model.
MODEL_NAME = "runwayml/stable-diffusion-v1-5" #@param {type:"string"}

#@markdown Enter the directory name to save model at.
OUTPUT_DIR = "2200" #@param {type:"string"}

# Jupyter Notebook에서 OUTPUT_DIR의 경로를 수정합니다.
if save_to_gdrive:
    OUTPUT_DIR = "2200"
else:
    OUTPUT_DIR = "2200"

print(f"[*] Weights will be saved at {OUTPUT_DIR}")

# 폴더를 만들 때 '-p' 옵션은 폴더가 이미 존재하는 경우 오류를 발생시키지 않도록 합니다.
os.makedirs(OUTPUT_DIR, exist_ok=True)

"""# Start Training

Use the table below to choose the best flags based on your memory and speed requirements. Tested on Tesla T4 GPU.


| `fp16` | `train_batch_size` | `gradient_accumulation_steps` | `gradient_checkpointing` | `use_8bit_adam` | GB VRAM usage | Speed (it/s) |
| ---- | ------------------ | ----------------------------- | ----------------------- | --------------- | ---------- | ------------ |
| fp16 | 1                  | 1                             | TRUE                    | TRUE            | 9.92       | 0.93         |
| no   | 1                  | 1                             | TRUE                    | TRUE            | 10.08      | 0.42         |
| fp16 | 2                  | 1                             | TRUE                    | TRUE            | 10.4       | 0.66         |
| fp16 | 1                  | 1                             | FALSE                   | TRUE            | 11.17      | 1.14         |
| no   | 1                  | 1                             | FALSE                   | TRUE            | 11.17      | 0.49         |
| fp16 | 1                  | 2                             | TRUE                    | TRUE            | 11.56      | 1            |
| fp16 | 2                  | 1                             | FALSE                   | TRUE            | 13.67      | 0.82         |
| fp16 | 1                  | 2                             | FALSE                   | TRUE            | 13.7       | 0.83          |
| fp16 | 1                  | 1                             | TRUE                    | FALSE           | 15.79      | 0.77         |

Add `--gradient_checkpointing` flag for around 9.92 GB VRAM usage.

remove `--use_8bit_adam` flag for full precision. Requires 15.79 GB with `--gradient_checkpointing` else 17.8 GB.

remove `--train_text_encoder` flag to reduce memory usage further, degrades output quality.
"""

# You can also add multiple concepts here. Try tweaking `--max_train_steps` accordingly.

concepts_list = [
    {
        "instance_prompt":      "a painting in bmb style",
        "class_prompt":         "style",
        "instance_data_dir":    "training_images/bmb",
        "class_data_dir":       "training_images/bmb"
    },
    {
        "instance_prompt":      "a painting in GRB style",
        "class_prompt":         "a painting in style",
        "instance_data_dir":    "training_images/GRB/style/a painting in",
        "class_data_dir":       "training_images/GRB/style/a painting in"
    },
        {
        "instance_prompt":      "a painting in MGB style ",
        "class_prompt":         "a painting in style",
        "instance_data_dir":    "training_images/MGB/style/a painting in",
        "class_data_dir":       "training_images/MGB/style/a painting in"
    }
]

import json
import os
for c in concepts_list:
    os.makedirs(c["instance_data_dir"], exist_ok=True)

with open("concepts_list.json", "w") as f:
    json.dump(concepts_list, f, indent=4)

#@markdown Specify the weights directory to use (leave blank for latest)
WEIGHTS_DIR ="2200/2200"#"/content/drive/MyDrive/stable_diffusion_wyle-0429/2200" #@param {type:"string"}
if WEIGHTS_DIR == "":
    from natsort import natsorted
    from glob import glob
    import os
    WEIGHTS_DIR = natsorted(glob(OUTPUT_DIR + os.sep + "*"))[-1]
print(f"[*] WEIGHTS_DIR={WEIGHTS_DIR}")

#@markdown Run to generate a grid of preview images from the last saved weights.
import os
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

weights_folder = OUTPUT_DIR
folders = sorted([f for f in os.listdir(weights_folder) if f != "0"], key=lambda x: int(x))

row = len(folders)
col = len(os.listdir(os.path.join(weights_folder, folders[0], "samples")))
scale = 4
fig, axes = plt.subplots(row, col, figsize=(col*scale, row*scale), gridspec_kw={'hspace': 0, 'wspace': 0})

for i, folder in enumerate(folders):
    folder_path = os.path.join(weights_folder, folder)
    image_folder = os.path.join(folder_path, "samples")
    images = [f for f in os.listdir(image_folder)]
    for j, image in enumerate(images):
        if row == 1:
            currAxes = axes[j]
        else:
            currAxes = axes[i, j]
        if i == 0:
            currAxes.set_title(f"Image {j}")
        if j == 0:
            currAxes.text(-0.1, 0.5, folder, rotation=0, va='center', ha='center', transform=currAxes.transAxes)
        image_path = os.path.join(image_folder, image)
        img = mpimg.imread(image_path)
        currAxes.imshow(img, cmap='gray')
        currAxes.axis('off')

plt.tight_layout()
plt.savefig('grid.png', dpi=72)

"""## Convert weights to ckpt to use in web UIs like AUTOMATIC1111."""

!pip install diffusers

!pip install bitsandbytes

!pip install --upgrade --force-reinstall bitsandbytes

!pip install --upgrade bitsandbytes transformers

!pip install transformers==4.10.3

!pip install --upgrade diffusers

import torch
from torch import autocast
from diffusers import StableDiffusionPipeline, DDIMScheduler
from IPython.display import display

model_path = str(WEIGHTS_DIR)  # Replace with the appropriate model path
print(model_path)

# Check if CUDA (GPU) is available
if torch.cuda.is_available():
    torch_device = "cuda"
else:
    torch_device = "cpu"

# Initialize the pipeline with the torch_device argument
pipe = StableDiffusionPipeline.from_pretrained(model_path, safety_checker=None, torch_device=torch_device)

pipe.scheduler = DDIMScheduler.from_config(pipe.scheduler.config)

# Enable memory-efficient attention if using GPU
if torch_device == "cuda":
    pipe.enable_xformers_memory_efficient_attention()

g_cuda = None

"""## Inference"""

import torch
from diffusers import StableDiffusionPipeline, DDIMScheduler
from IPython.display import display

# CUDA를 사용하지 않도록 설정하여 CPU에서 실행하도록 설정
torch.backends.cudnn.enabled = False
torch.cuda.is_available = lambda: False

model_path = str(WEIGHTS_DIR)  # If you want to use previously trained model saved in gdrive, replace this with the full path of the model in gdrive
print(model_path)

pipe = StableDiffusionPipeline.from_pretrained(model_path, torch_device="cpu", torch_dtype=torch.float32, safety_checker=None)
pipe.scheduler = DDIMScheduler.from_config(pipe.scheduler.config)
# xformers 라이브러리를 사용하지 않도록 설정
pipe.use_xformers_memory_efficient_attention = False

# xformers를 사용하지 않기 때문에 이 함수를 호출할 필요가 없어집니다.
# pipe.enable_xformers_memory_efficient_attention()

g_cuda = None



#@markdown Can set random seed here for reproducibility.
g_cuda = torch.Generator()
seed = 51223 #@param {type:"number"}
g_cuda.manual_seed(seed)

#@title Run for generating images.
#molgolbub
#baeckmyobub
#gurekbub
prompt = "a painting in bmb style, top - cloud, middle - mountains, bottom - river " #@param {type:"string"}
negative_prompt = "" #@param {type:"string"}
num_samples = 1 #@param {type:"number"}
guidance_scale = 7.5 #@param {type:"number"}
num_inference_steps = 50 #@param {type:"number"}
height = 512 #@param {type:"number"}
width = 512 #@param {type:"number"}

with autocast("cuda"), torch.inference_mode():
    images = pipe(
        prompt,
        height=height,
        width=width,
        negative_prompt=negative_prompt,
        num_images_per_prompt=num_samples,
        num_inference_steps=num_inference_steps,
        guidance_scale=guidance_scale,
        generator=g_cuda
    ).images


for image in images:
    display(image.convert('L'))
print(type(image))

#@title (Optional) Delete diffuser and old weights and only keep the ckpt to free up drive space.

#@markdown [ ! ] Caution, Only execute if you are sure u want to delete the diffuser format weights and only use the ckpt.
import shutil
from glob import glob
import os
for f in glob(OUTPUT_DIR+os.sep+"*"):
    if f != WEIGHTS_DIR:
        shutil.rmtree(f)
        print("Deleted", f)
for f in glob(WEIGHTS_DIR+"/*"):
    if not f.endswith(".ckpt") or not f.endswith(".json"):
        try:
            shutil.rmtree(f)
        except NotADirectoryError:
            continue
        print("Deleted", f)

#@title Free runtime memory
exit()

!pip install flask

!pip install pyngrok

import os
os.getcwd()
import io
import base64
from PIL import Image

!pip install psycopg2-binary

import psycopg2
from psycopg2 import OperationalError

def check_postgresql_connection():
    try:
        # PostgreSQL 데이터베이스 연결 정보 설정
        db_params = {
            "host": "localhost",
            "database": "sample1",
            "user": "postgres",
            "password": "qwer1234"
        }

        # PostgreSQL 데이터베이스에 연결 시도
        connection = psycopg2.connect(**db_params)

        # 연결 성공 메시지 출력
        print("Connected to PostgreSQL")

        # 연결 닫기
        connection.close()

    except OperationalError as e:
        # 연결 실패 메시지 출력
        print(f"Error: {e}")

# PostgreSQL 데이터베이스 접속 확인
check_postgresql_connection()

#회원가입 db테이블 생성

import psycopg2
from psycopg2 import OperationalError

def create_table():
    try:
        # PostgreSQL 데이터베이스 연결 정보 설정
        db_params = {
            "host": "localhost",
            "database": "postgres",
            "user": "postgres",
            "password": "qwer1234"
        }

        # PostgreSQL 데이터베이스에 연결
        connection = psycopg2.connect(**db_params)
        cursor = connection.cursor()

        # 테이블 생성 SQL 쿼리
        create_table_query = '''
            CREATE TABLE "users" (
                id SERIAL PRIMARY KEY,
                username VARCHAR(255) NOT NULL,
                password VARCHAR(255) NOT NULL,
                email VARCHAR(255) NOT NULL
            );
        '''

        # 테이블 생성 쿼리 실행
        cursor.execute(create_table_query)
        connection.commit()

        # 연결 닫기
        cursor.close()
        connection.close()

        print("Table created successfully")

    except OperationalError as e:
        print(f"Error: {e}")

# 테이블 생성 함수 호출
create_table()

"""--------------------------------------------------------------------------------"""

!pip install flask_session

!pip install Flask-SQLAlchemy

"""--------------------------------------------------------------------------------"""

from flask import Flask, render_template, request, redirect, url_for, session
from flask_session import Session
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime
import os
from werkzeug.security import generate_password_hash, check_password_hash
import psycopg2
import logging
from werkzeug.utils import secure_filename


app = Flask(__name__)
app.secret_key = 'qwer1234'

# PostgreSQL 연결 정보
db_host = "localhost"
db_name = "postgres"
db_user = "postgres"
db_password = "qwer1234"




def create_connection():
    connection = psycopg2.connect(
        host=db_host, dbname=db_name, user=db_user, password=db_password
    )
    return connection



app.config['UPLOAD_FOLDER'] = 'static/uploads'  # uploads 디렉토리로 저장하려면 이 경로를 수정하세요
# PostgreSQL 연결 정보
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://postgres:qwer1234@localhost/postgres'
db = SQLAlchemy(app)

class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    author = db.Column(db.String(50), nullable=False)
    content = db.Column(db.Text, nullable=False)
    image_filename = db.Column(db.String(255))  # 이미지 파일 이름을 저장할 필드 추가
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    views = db.Column(db.Integer, default=0)


# Papago API 정보
client_id = "Y1PrO9u17bCQJih_nFkd"
client_secret = "qeoUyCkD57"
detect_langs_url = "https://openapi.naver.com/v1/papago/detectLangs"
translate_url = "https://openapi.naver.com/v1/papago/n2mt"

def detect_language(text):
    headers = {
        "X-Naver-Client-Id": client_id,
        "X-Naver-Client-Secret": client_secret
    }
    data = {
        "query": text
    }
    response = requests.post(detect_langs_url, headers=headers, data=data).json()
    language_code = response['langCode']
    return language_code

def translate_text(text, source_lang, target_lang):
    headers = {
        "X-Naver-Client-Id": client_id,
        "X-Naver-Client-Secret": client_secret
    }
    data = {
        "source": source_lang,
        "target": target_lang,
        "text": text
    }
    response = requests.post(translate_url, headers=headers, data=data).json()
    translated_text = response['message']['result']['translatedText']
    return translated_text


@app.route('/')
def index():
    logged_in = 'username' in session  # 로그인 여부 확인
    return render_template('main.html', logged_in=logged_in)

@app.route('/about')
def about():
    logged_in = 'username' in session  # 로그인 여부 확인
    return render_template('about.html', logged_in=logged_in)


@app.route('/community')
def community():
    logged_in = 'username' in session  # 로그인 여부 확인
    posts = Post.query.all()
    return render_template('list.html', posts=posts, logged_in=logged_in)

@app.route('/write', methods=['GET', 'POST'])
def write():
    logged_in = 'username' in session
    if request.method == 'POST':
        title = request.form['title']
        author = request.form['author']
        content = request.form['content']

        if not title or not author or not content:
            error_message = "모든 필드를 입력해주세요."
            return render_template('write.html', error_message=error_message)

        image = request.files['image']
        if image:
            filename = secure_filename(image.filename)
            upload_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            image.save(upload_path)

            new_post = Post(title=title, author=author, content=content, image_filename=filename)
        else:
            new_post = Post(title=title, author=author, content=content)

        db.session.add(new_post)
        db.session.commit()

        return redirect(url_for('community'))

    return render_template('write.html')


@app.route('/view/<int:post_id>')
def view(post_id):
    logged_in = 'username' in session
    post = Post.query.get(post_id)
    if post is None:
        return render_template('error.html', error_message="게시물을 찾을 수 없습니다.")

    # 조회수 증가 코드 추가
    post.views = post.views + 1
    db.session.commit()

    return render_template('view.html', post=post)




@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('index'))

@app.route('/sign', methods=['GET', 'POST'])
def signup():
    app.logger.debug('Entering signup function')
    error_message = None  # 오류 메시지를 초기화

    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        confirm_password = request.form['confirm-password']

        if password != confirm_password:
            error_message = "비밀번호가 일치하지 않습니다."
        else:
            email = request.form['email']

            try:
                connection = create_connection()
                cursor = connection.cursor()

                cursor.execute("SELECT * FROM users WHERE username = %s", (username,))
                existing_user = cursor.fetchone()

                if existing_user:
                    error_message = "이미 존재하는 아이디입니다."
                else:
                    hashed_password = generate_password_hash(password, method='sha256')
                    cursor.execute("INSERT INTO users (username, password, email) VALUES (%s, %s, %s)", (username, hashed_password, email))
                    connection.commit()
            except Exception as e:
                error_message = str(e)
            finally:
                cursor.close()
                connection.close()

                if not error_message:  # 오류 메시지가 없을 경우에만 로그인 페이지로 이동
                    return redirect(url_for('login'))

    return render_template('sign.html', error_message=error_message)


@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']

        try:
            connection = create_connection()
            cursor = connection.cursor()

            cursor.execute("SELECT * FROM users WHERE username = %s", (username,))
            user = cursor.fetchone()

            if user and check_password_hash(user[2], password):
                session['username'] = username  # 로그인 성공시 세션 변수에 사용자 이름 저장
                return redirect(url_for('index'))
            else:
                error_message = "로그인 실패: 아이디 또는 비밀번호가 올바르지 않습니다."
                return render_template('login.html', error_message=error_message)

        except Exception as e:
            return str(e)
        finally:
            cursor.close()
            connection.close()

    return render_template('login.html')

@app.route('/find_id', methods=['GET', 'POST'])
def find_id():
    found_username = None
    not_found_message = None

    if request.method == 'POST':
        email = request.form['email']

        try:
            connection = create_connection()
            cursor = connection.cursor()

            cursor.execute("SELECT username FROM users WHERE email = %s", (email,))
            user = cursor.fetchone()

            if user:
                found_username = user[0]
            else:
                not_found_message = "일치하는 아이디가 없습니다."

        except Exception as e:
            return str(e)
        finally:
            cursor.close()
            connection.close()

    return render_template('id.html', found_username=found_username, not_found_message=not_found_message)

@app.route('/find_pass', methods=['GET', 'POST'])
def find_password():
    found_password = None
    not_found_message = None

    if request.method == 'POST':
        id = request.form['id']
        email = request.form['email']

        try:
            connection = create_connection()
            cursor = connection.cursor()

            cursor.execute("SELECT password FROM users WHERE username = %s AND email = %s", (id, email))
            password = cursor.fetchone()

            if password:
                found_password = password[0]
            else:
                not_found_message = "일치하는 정보가 없습니다."

        except Exception as e:
            return str(e)
        finally:
            cursor.close()
            connection.close()

    return render_template('pass.html', found_password=found_password, not_found_message=not_found_message)


@app.route('/draw', methods=['GET', 'POST'])
def draw():
    logged_in = 'username' in session
    if request.method == 'POST':
        # 웹에서 입력한 정보 받아오기
        input_data = request.form['input_data']
        text_to_translate = input_data
        source_lang = detect_language(text_to_translate)
        target_lang = 'en'  # 영어로 번역하고 싶다면 'en'으로 변경 가능

        translated_text = translate_text(text_to_translate, source_lang, target_lang)

        paint_style = request.form.get('selectedBox')
        prompt = f"a painting in {paint_style}, {translated_text} " #@param {type:"string"}        negative_prompt = "" #@param {type:"string"}
        num_samples = 2 #@param {type:"number"}
        guidance_scale = 7.5 #@param {type:"number"}
        num_inference_steps = 50 #@param {type:"number"}
        height = 512 #@param {type:"number"}
        width = 512 #@param {type:"number"}

        with autocast("cuda"), torch.inference_mode():
            images = pipe(
                prompt,
                height=height,
                width=width,
                negative_prompt=negative_prompt,
                num_images_per_prompt=num_samples,
                num_inference_steps=num_inference_steps,
                guidance_scale=guidance_scale,
                generator=g_cuda
            ).images

        for image in images:
          a=image.convert('L') #
        img_byte_array = io.BytesIO()
        a.save(img_byte_array, format='PNG')
        encoded_img_data = base64.b64encode(img_byte_array.getvalue()).decode('utf-8')

        # 입력받은 정보를 그대로 출력
        return render_template('draw.html', output_data=encoded_img_data)

    return render_template('draw.html', logged_in=logged_in)



if __name__ == '__main__':
    with app.app_context():
        db.create_all()
        app.run()